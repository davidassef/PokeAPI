"""
Servi√ßo de ranking baseado no armazenamento consolidado dos clientes.

Este m√≥dulo implementa a l√≥gica de neg√≥cio para gera√ß√£o e atualiza√ß√£o
do ranking global de Pok√©mons mais capturados, baseado nos dados
consolidados de todos os clientes conectados ao sistema.
"""

import logging
from typing import Dict, List
from sqlalchemy.orm import Session
from datetime import datetime

from app.models.models import PokemonRanking
from app.services.client_storage_service import ClientStorageService

logger = logging.getLogger(__name__)


class RankingService:
    """
    Servi√ßo para gerenciamento do ranking global de Pok√©mons.

    Respons√°vel por calcular e manter atualizado o ranking dos Pok√©mons
    mais capturados baseado nos dados consolidados de todos os clientes
    conectados ao sistema pull-based.

    Attributes:
        storage_service: Servi√ßo de armazenamento de dados dos clientes
    """

    def __init__(self, storage_service: ClientStorageService):
        """
        Inicializa o servi√ßo de ranking.

        Args:
            storage_service: Inst√¢ncia do servi√ßo de armazenamento de clientes
        """
        self.storage_service = storage_service

    def update_ranking_from_storage(self, db: Session, force_update: bool = False) -> Dict[str, int]:
        """
        Atualiza a tabela de ranking baseado nos dados consolidados do storage.

        Este m√©todo reconstr√≥i completamente o ranking global removendo
        todas as entradas existentes e inserindo novos dados baseados
        nas capturas consolidadas de todos os clientes.

        Args:
            db: Sess√£o do banco de dados
            force_update: Se True, for√ßa atualiza√ß√£o mesmo se n√£o houver mudan√ßas

        Returns:
            Dict[str, int]: Estat√≠sticas da atualiza√ß√£o contendo:
                - deleted_count: N√∫mero de entradas removidas
                - inserted_count: N√∫mero de entradas inseridas
                - errors_count: N√∫mero de erros durante inser√ß√£o

        Note:
            Esta opera√ß√£o √© custosa pois reconstr√≥i todo o ranking.
            Use com modera√ß√£o em sistemas com muitos dados.
        """
        logger.info("üèÜ Iniciando atualiza√ß√£o do ranking baseado no storage")

        # Obt√©m dados consolidados do ranking de todos os clientes
        ranking_data = self.storage_service.get_ranking_data(limit=100)
        logger.info(f"üìä Dados do ranking obtidos: {len(ranking_data)} entradas")

        # Remove todas as entradas existentes do ranking
        deleted_count = db.query(PokemonRanking).count()
        db.query(PokemonRanking).delete()
        logger.info(f"üóëÔ∏è Removidas {deleted_count} entradas antigas do ranking")

        # Insere novas entradas baseadas nos dados consolidados
        inserted_count = 0
        errors_count = 0

        for pokemon_id, capture_count in ranking_data:
            try:
                # Obt√©m nome do Pok√©mon (pode ser otimizado com cache futuro)
                pokemon_name = self._get_pokemon_name(pokemon_id)

                # Cria nova entrada de ranking
                ranking_entry = PokemonRanking(
                    pokemon_id=pokemon_id,
                    pokemon_name=pokemon_name,
                    favorite_count=capture_count,
                    last_updated=datetime.now()
                )

                db.add(ranking_entry)
                inserted_count += 1

                logger.info(f"‚ûï Adicionado ao ranking: {pokemon_name} (ID: {pokemon_id}) - {capture_count} capturas")

            except Exception as e:
                errors_count += 1
                logger.error(f"‚ùå Erro ao inserir ranking para pok√©mon {pokemon_id}: {e}")

        # Persiste todas as mudan√ßas no banco
        try:
            db.commit()
            logger.info(f"‚úÖ Commit realizado com sucesso: {inserted_count} entradas inseridas")
        except Exception as e:
            logger.error(f"‚ùå Erro no commit: {e}")
            db.rollback()
            raise

        # Compila estat√≠sticas da opera√ß√£o
        stats = {
            "deleted_count": deleted_count,
            "inserted_count": inserted_count,
            "errors_count": errors_count,
            "total_unique_pokemons": len(ranking_data),
            "top_pokemon_id": ranking_data[0][0] if ranking_data else None,
            "top_pokemon_count": ranking_data[0][1] if ranking_data else 0
        }

        logger.info(f"üéØ Ranking atualizado com sucesso: {inserted_count} entradas inseridas")
        return stats

    def get_ranking(self, db: Session, limit: int = 10) -> List[PokemonRanking]:
        """
        Retorna o ranking atual dos Pok√©mons mais capturados.

        Busca as entradas do ranking ordenadas por n√∫mero de capturas
        em ordem decrescente, com desempate por ID do Pok√©mon.

        Args:
            db: Sess√£o do banco de dados
            limit: N√∫mero m√°ximo de Pok√©mons no ranking (padr√£o: 10)

        Returns:
            List[PokemonRanking]: Lista ordenada das entradas do ranking
        """
        return (
            db.query(PokemonRanking)
            .order_by(
                PokemonRanking.favorite_count.desc(),
                PokemonRanking.pokemon_id.asc()  # Desempate por ID
            )
            .limit(limit)
            .all()
        )

    def get_ranking_with_storage_comparison(self, db: Session, limit: int = 10) -> Dict:
        """
        Retorna ranking atual e compara com dados do storage para verifica√ß√£o.

        M√©todo √∫til para debug e verifica√ß√£o de consist√™ncia entre
        os dados persistidos no banco e os dados consolidados no storage.

        Args:
            db: Sess√£o do banco de dados
            limit: N√∫mero m√°ximo de itens para compara√ß√£o

        Returns:
            Dict: Dicion√°rio contendo ranking do banco, storage e an√°lise de consist√™ncia
        """
        # Obt√©m ranking atual do banco de dados
        db_ranking = self.get_ranking(db, limit)

        # Obt√©m ranking consolidado do storage
        storage_ranking = self.storage_service.get_ranking_data(limit)

        # Analisa consist√™ncia entre as duas fontes
        is_consistent = True
        differences = []

        # Compara posi√ß√£o por posi√ß√£o entre banco e storage
        for i, (storage_id, storage_count) in enumerate(storage_ranking):
            if i < len(db_ranking):
                db_entry = db_ranking[i]
                # Verifica se ID e contagem coincidem
                if db_entry.pokemon_id != storage_id or db_entry.favorite_count != storage_count:
                    is_consistent = False
                    differences.append({
                        "position": i + 1,
                        "storage": {"id": storage_id, "count": storage_count},
                        "database": {"id": db_entry.pokemon_id, "count": db_entry.favorite_count}
                    })
            else:
                # Storage tem mais entradas que o banco
                is_consistent = False
                differences.append({
                    "position": i + 1,
                    "storage": {"id": storage_id, "count": storage_count},
                    "database": None
                })

        return {
            "database_ranking": [
                {
                    "position": i + 1,
                    "pokemon_id": entry.pokemon_id,
                    "pokemon_name": entry.pokemon_name,
                    "capture_count": entry.favorite_count,
                    "last_updated": entry.last_updated.isoformat() if entry.last_updated else None
                }
                for i, entry in enumerate(db_ranking)
            ],
            "storage_ranking": [
                {
                    "position": i + 1,
                    "pokemon_id": pokemon_id,
                    "capture_count": count,
                    "pokemon_name": self._get_pokemon_name(pokemon_id)
                }
                for i, (pokemon_id, count) in enumerate(storage_ranking)
            ],
            "is_consistent": is_consistent,
            "differences": differences,
            "storage_stats": self.storage_service.get_storage_stats()
        }

    def _get_pokemon_name(self, pokemon_id: int) -> str:
        """
        Obt√©m o nome do Pok√©mon baseado no seu ID.

        Implementa√ß√£o tempor√°ria usando mapeamento est√°tico dos Pok√©mons
        mais comuns. Em produ√ß√£o, deveria usar cache ou busca na API/database.

        Args:
            pokemon_id: ID do Pok√©mon na PokeAPI

        Returns:
            str: Nome do Pok√©mon ou fallback "pokemon_{id}"

        TODO:
            Implementar cache persistente ou integra√ß√£o com PokeAPI
            para obter nomes de todos os Pok√©mons dinamicamente.
        """
        # Mapeamento est√°tico dos Pok√©mons mais populares
        pokemon_names = {
            1: "bulbasaur", 2: "ivysaur", 3: "venusaur", 4: "charmander",
            5: "charmeleon", 6: "charizard", 7: "squirtle", 8: "wartortle",
            9: "blastoise", 10: "caterpie", 11: "metapod", 12: "butterfree",
            13: "weedle", 14: "kakuna", 15: "beedrill", 16: "pidgey",
            17: "pidgeotto", 18: "pidgeot", 19: "rattata", 20: "raticate",
            21: "spearow", 22: "fearow", 23: "ekans", 24: "arbok",
            25: "pikachu", 26: "raichu", 27: "sandshrew", 28: "sandslash",
            29: "nidoran-f", 30: "nidorina", 31: "nidoqueen", 32: "nidoran-m",
            33: "nidorino", 34: "nidoking", 35: "clefairy", 36: "clefable",
            37: "vulpix", 38: "ninetales", 39: "jigglypuff", 40: "wigglytuff",
            94: "gengar", 130: "gyarados", 144: "articuno", 150: "mewtwo"
        }
        return pokemon_names.get(pokemon_id, f"pokemon_{pokemon_id}")

    def force_ranking_rebuild(self, db: Session) -> Dict[str, int]:
        """
        For√ßa a reconstru√ß√£o completa do ranking do zero.

        Remove todos os dados existentes do ranking e reconstr√≥i
        completamente baseado nos dados consolidados do storage.

        Args:
            db: Sess√£o do banco de dados

        Returns:
            Dict[str, int]: Estat√≠sticas da reconstru√ß√£o incluindo:
                - deleted_count: Entradas removidas
                - inserted_count: Entradas inseridas
                - errors_count: Erros durante inser√ß√£o

        Warning:
            Opera√ß√£o custosa que reconstr√≥i todo o ranking.
            Use apenas quando necess√°rio para corre√ß√£o de inconsist√™ncias.
        """
        logger.info("üîÑ Iniciando reconstru√ß√£o completa for√ßada do ranking")

        # Remove todas as entradas existentes
        deleted_count = db.query(PokemonRanking).count()
        db.query(PokemonRanking).delete()

        # Reconstr√≥i ranking baseado no storage atual
        stats = self.update_ranking_from_storage(db, force_update=True)
        stats["deleted_count"] = deleted_count

        logger.info(f"üéØ Ranking reconstru√≠do com sucesso: {deleted_count} removidos, {stats['inserted_count']} inseridos")
        return stats
